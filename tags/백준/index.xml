<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>백준 on meinego</title>
    <link>https://meinego.github.io/tags/%EB%B0%B1%EC%A4%80/</link>
    <description>Recent content in 백준 on meinego</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <copyright>© {year}</copyright>
    <lastBuildDate>Thu, 24 Mar 2022 18:55:25 +0900</lastBuildDate><atom:link href="https://meinego.github.io/tags/%EB%B0%B1%EC%A4%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>11438. LCA 2</title>
      <link>https://meinego.github.io/acm/11438/</link>
      <pubDate>Thu, 24 Mar 2022 18:55:25 +0900</pubDate>
      
      <guid>https://meinego.github.io/acm/11438/</guid>
      <description>문제 루트가 1인 트리가 주어질 때 최소공통조상을 \(O(log N)\)에 찾는 문제
풀이 노드마다 \(2^{i}\) 번째 부모를 미리 구해놓으면 된다.
\(\text{1. DFS를 통해 노드들의 depth를 구한다.}\)
\(\text{2. parent[node_idx][max_log_n] 을 구한다.}\)
\(\text{3. 찾으려고하는 노드 A, B의 depth를 같게 만든다.}\)
\(\text{4. 부모가 같아질 때까지 A, B를 거슬러 올라간다. }\)
코드 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; #define N 100&#39;000 #define logN 16 vector&amp;lt;int&amp;gt; adj[N+1]; int d[N+1], p[N+1][logN+1]; int n,m; void dfs(int u) { for (int v: adj[u]) { if (d[v] !</description>
    </item>
    
    <item>
      <title>1620. 나는야 포켓몬 마스터 이다솜</title>
      <link>https://meinego.github.io/acm/1620/</link>
      <pubDate>Tue, 22 Mar 2022 20:52:57 +0900</pubDate>
      
      <guid>https://meinego.github.io/acm/1620/</guid>
      <description>문제 포켓몬 도감이 주어질 때 index -&amp;gt; 포켓몬이름, 포켓몬이름-&amp;gt;index 를 구하는 문제
풀이 map을 2개 생성하고 조회하면 된다.
코드 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; #define N 100&#39;000 string arr[N+1]; int n, m; int main() { ios::sync_with_stdio(false); cin.tie(0); cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m; map&amp;lt;string, string&amp;gt; name2id; map&amp;lt;string, string&amp;gt; id2name; for (int i=1; i&amp;lt;=n; ++i) { string s; cin&amp;gt;&amp;gt;s; name2id[s] = to_string(i); id2name[to_string(i)] = s; } for (int i=0; i&amp;lt;m; ++i) { string s; cin&amp;gt;&amp;gt;s; if (name2id.</description>
    </item>
    
    <item>
      <title>11723. 집합</title>
      <link>https://meinego.github.io/acm/11723/</link>
      <pubDate>Tue, 22 Mar 2022 20:24:42 +0900</pubDate>
      
      <guid>https://meinego.github.io/acm/11723/</guid>
      <description>문제 비어있는 공집합 S가 주어졌을 때, 아래 연산을 수행하는 프로그램을 작성하시오.
add x S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
remove x S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다.
check x S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20)
toggle x S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20)</description>
    </item>
    
    <item>
      <title>1000. A&#43;B</title>
      <link>https://meinego.github.io/acm/1000/</link>
      <pubDate>Tue, 22 Mar 2022 20:21:49 +0900</pubDate>
      
      <guid>https://meinego.github.io/acm/1000/</guid>
      <description>문제 0 &amp;lt; A, B &amp;lt; 10 자연수가 주어질 때, A+B를 구하는 문제
풀이 stdout으로 A+B를 출력하면 된다.
코드 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; int a,b; int main() { cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b; cout &amp;lt;&amp;lt; a+b; return 0; }  링크 https://acmicpc.net/problem/1000</description>
    </item>
    
    <item>
      <title>7662. 이중 우선순위 큐</title>
      <link>https://meinego.github.io/acm/7662/</link>
      <pubDate>Tue, 22 Mar 2022 19:35:14 +0900</pubDate>
      
      <guid>https://meinego.github.io/acm/7662/</guid>
      <description>문제 m &amp;lt;= 1e6 다음 연산들을 총 m번 수행 후 큐의 최댓값, 최솟값을 구하라.
I x x를 추가
D 1 최댓값을 삭제
D -1 최솟값을 삭제
단, 같은 값을 여러번 추가할 수 있으며, 빈 큐에 삭제 연산이 불릴 수도 있다.
m번의 연산 후 큐가 비어있으면 EMPTY를 출력한다.
풀이 추가 시엔 최소힙과 최대힙에 넣고 삭제시엔 하나의 힙에서 삭제한다.
큐에 들어가 있는 개수를 저장하여 큐가 비었는지 확인하며
삽입된 수마다 큐에 있는 개수를 저장하여 삭제시에 유효한 값인지 확인한다.</description>
    </item>
    
  </channel>
</rss>
